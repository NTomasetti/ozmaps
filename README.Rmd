---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
library(dplyr)
library(sf)
library(rmapshaper)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# ozplot

The goal of ozplot is to get maps of Australia to plot!

The package doesn't do anything yet, it's just a place to park this code below. 

## Obtain a set of polygon map files 


This block of code will download a ~1.5Gb zip file with 
many shapefiles in nested folders. I originally chose the MapInfo format, but those had empty geometries(!). 



```{r download, eval = FALSE}
#f <- "https://data.gov.au/dataset/bdcf5b09-89bc-47ec-9281-6b8e9ee147aa/resource/cb2d6c1c-fd4c-4fd7-b93b-3796425bc0de/download/aug17adminboundsmapinfotabformat20170828133827.zip"
f <- "https://data.gov.au/dataset/bdcf5b09-89bc-47ec-9281-6b8e9ee147aa/resource/53c24b8e-4f55-4eed-a189-2fc0dcca6381/download/aug17adminboundsesrishapefileordbffile20170821151234.zip"
download.file(f, basename(f), mode = "wb")
unzip(basename(f))

```

I discovered these links (ESRI Shapefile and MapInfo) at this site: https://data.gov.au/dataset/psma-administrative-boundaries 


Build a data frame of the available file names, it's a 
recursive tree of directories but we only need the ".shp$" values. 

```{r files}
library(dplyr)
fs <- tibble::tibble(fullname = list.files(".", recursive = TRUE, pattern = "shp$"))

## keep file and fullname, a habit of mine
fs <- fs %>% dplyr::mutate(file = basename(fullname)) %>% dplyr::select(file, fullname)

fs 

## read all files and bind together in one object
## (I find problems using map_df so I just avoid it
## and ensure sf is attached)
read_psma <- function(x) {
  library(sf)
  do.call(rbind, purrr::map(x, sf::read_sf))
}
```


```{r explore}
## ignore state and see what layers there are
## there are 32 different kinds of layers
sort(unique(unlist(lapply(strsplit(fs$file, "_"), function(x) paste(tail(x, -1), collapse = "_")))))
```


No we can filter on the state-removed strings to get the entire set for the country. 

```{r data}
## all LGA
lga <- read_psma(fs %>% dplyr::filter(grepl("LGA_POLYGON", file)) %>% dplyr::pull(fullname))

## note that the "geometry" column is sticky, we
## subset like this to avoid faceting on all columns
plot(lga[1])

## electoral
elec <- read_psma(fs %>% dplyr::filter(grepl("STATE_ELECTORAL_POLYGON", file)) %>% dplyr::pull(fullname))

plot(elec[1])

## state
state <- read_psma(fs %>% dplyr::filter(grepl("STATE_POLYGON", file)) %>% dplyr::pull(fullname))
plot(state[1])
abline(v = 148, h = -43)

## that is very high resolution, checkout 
plot(state[1], xlim = c(147.7, 148.2), ylim = c(-43.3, -43.0))
abline(v = 148, h = -43)

pryr::object_size(state)

## use rmapshaper for topological simplification
## (but avoid date columns which trigger a bug in 0.3.0)
simple_state <- rmapshaper::ms_simplify(state[c("ST_PLY_PID", "STATE_PID", "geometry")])
pryr::object_size(simple_state)
plot(simple_state[1], xlim = c(147.7, 148.2), ylim = c(-43.3, -43.0))
plot(simple_state[1])
```

Another location. 

```{r cloudy}
## that is very high resolution, checkout 
plot(state[1], xlim = c(146.7, 148.2), ylim = c(-44.3, -43.0))
abline(v = 147.2385, h = -43.46973)

plot(state[1], xlim = 147.2385 + c(-1, 1)/30, 
     ylim = -43.46973 + c(-1, 1)/30, border = NA)

plot(st_geometry(simple_state), add = TRUE)
abline(v = 147.2385, h = -43.46973)



```
